---
title: 体验优化系列之——消费记录列表页体验优化报告
date: 2020-06-03
comments: true
sidebar: 'auto'
category: experience
tags:
 - 用户体验
---

## 现状

消费记录列表页是用户浏览最多的页面之一，但是这个列表页的体验目前来说却不是很好。从各个方面收集到的反馈来看，体验问题主要集中在以下两点：

1. 首屏时间太长，约**3~4s**

2. 下拉刷新时，loading 图标阻碍操作

对于一个高频的简单页面来说，这个等待时间无疑是不合格的，它给用户的体验并不好。
因为研究表明，用户越来越不愿意浪费时间在等待上，最佳等待时间应该在1s以内。而对于一些追求极致的用户来说，他们更期望的是完全不用等待，至少感觉不到在等待。

## 优化目标

* 降低首屏时间至 1s 以内
* 优化刷新列表的交互体验

## 问题分析

影响插件首屏时间主要有以下几点：

### SDK耗时

从点击插件到 DeviceReady，我们把这一段时间归属于 SDK 耗时。

SDK主要在处理包括插件版本更新、7z解压文件校验、bridge注入等操作，SDK 耗时对任意插件来说区别
不大，而且也是H5无法优化的地带，这将由SDK团队负责优化。

我们通过性能统计平台可以查到这个时间大致为 0.5s。

### 静态资源加载

对于离线包来说，所有资源都存储在APP内部，这一块的读取时间几乎为 0。

而如果是内嵌的在线 H5页面则需要考虑这一点，这里我们不做过多描述。

### js运行时间

从 DeviceReady 到页面关闭骨架屏，剔除接口时间的耗时。

包括一系列js 脚步的执行时间，如vue框架运行、fastclick挂载、页面渲染等，这个时间要减去
接口时间来统计。这个时间在不同手机上并不一样，和手机的性能有直接关系。

### 接口时间

这里只包括直接影响首屏渲染的接口，对于消费记录来说，这样的接口有三个，通过查询CAT产线接口统计，还可以查到他们的耗时：

接口 | 最大耗时/s | 平均耗时/s |
- | :-: | :-: |
1. 查询用户信息 | 1.7 | 0.2 |
2. 查询订单列表 | 10.2 | 2.2 |
3. 查询订单分类 | 0.6 | 0.1 |

其中接口1和接口2是串行请求，接口1请求完成后，会去请求接口2，接口2请求完成后将关闭骨架屏，显示订单列表。接口3是并行请求，影响订单头部类别展示。

可以看到最大瓶颈在“查询订单列表”，如果有用户遇到最大 10.2 的等待时间，他无疑是会崩溃的。

## 优化方案

### 减少接口

“查询用户信息” 接口，用于查询员工的离职状态，这个信息是可以从 native 获取到的。所以让 native 增加了一个 `getUserInfo` 的同步API来替代。

### 缓存

用户第一次进入消费记录的时候，对接口2和接口3设置缓存，缓存的 `key` 通过 `userId` 来区分，如
`CONSUMRECORD_LIST_${userId}` 。

当用户第二次进入的时候，先从缓存中读取数据用于展示，然后静默请求接口更新列表。这样一来，用户进入列表页的时候可以直接看到数据，而不用请求任何接口，即便是在弱网环境。

下面是一组缓存优化前后的首屏时间对比:(测试环境)

系统 | 优化前首屏时间/ms | 优化后首屏时间/ms |
- | :-: | :-: |
ios | 829 | 140 |
安卓 | 1460 | 665 |

可以看到优化后的首屏时间降到了 1s 以内了，而且不管接口有多慢，该页面的首屏时间都会比较稳定。
而优化前的首屏时间则非常依赖接口的速度，按照产线接口的平均耗时来看，优化前产线的首屏时间在 `2.5~12s` 范围波动。

### 插件预加载

这里指的是在进入APP首页，还没有点击消费记录之前，native 预先加载消费记录。假如用户在首页停留 1s 后，再去点击消费记录，那么他就感觉不到任何的等待。这个功能已经由 native 实现。

### 刷新优化

native 给频道页封装了两个 tab 事件，分别是 `tabSwitch` 和 `tabClick`，用于帮助我们做刷新优化，通过静默和主动下拉刷新来替代阻碍操作的 loading 图标。

事件 | 含义 |  作用 |
- | :-: | - |
tabSwitch | tab切换到频道页时 |  静默刷新列表   |
tabClick | 在频道页点击tab时 |  主动下拉刷新列表|

以下是实现逻辑：

```js
window.onActivityResume = (param) => {
	const action = param.action;
	const tabSwitch = action === 'tabSwitch';
	const tabClick = action === 'tabClick';
	const stayTop = this.scrollY === 0;

	// 在当前tab页，点击tab，自动下拉刷新
	if (tabClick) {
		this.autoPullDownRefresh();
	}

	// tab切换，静默请求
	if (tabSwitch && stayTop) {
		this.refreshOrder(false);
	}
}
```

## 优化结果

通过上述优化方案，我们最终达成了我们的优化目标，即：

1. 通过减少接口、缓存优化，将列表页的首屏时间降至 1s 以内；
2. 通过插件预加载，进一步减少等待时间，甚至无需等待；
3. 通过静默、主动下拉刷新替代阻塞操作的全局 loading；

## 进一步的优化

优化到这个程度，是否还有优化空间？

有的！

1. 安卓的 js 运行时间为什么长达 665ms，远高于 ios 的 140ms，是不是可以提速？
2. 平均耗时 2.2s 的订单列表接口是不是可以提速到 1s 以内？
3. any more ???
